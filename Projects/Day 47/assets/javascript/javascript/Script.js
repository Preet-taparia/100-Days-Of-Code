const chessboardParent=document.getElementById("chessboard");class Chess{constructor(){this.setDefault()}setDefault(){this.info={preview:!1,started:!1,ended:!1,won:null,turn:null,timer:10},this.data={players:[],matchHistory:[],board:null}}async init(e){this.data.board=new Board(this),this.data.board.create(),await this.assignPlayers(),await this.data.players[0].init(this),await this.data.players[1].init(this),e&&e.call(this)}async assignPlayers(){return new Promise((e=>{const t=new Player({username:"Player 1",id:1,role:"white"}),i=new Player({username:"Player 2",id:2,role:"black"});this.data.players=[t,i],this.info.turn=t,t.info.isTurn=!0,e()}))}start(){this.info.started=!0,this.info.ended=!1,this.info.won=!1,this.data.board.placePiecesAsDefault(),this.data.players.forEach((e=>e.startTimer()))}notify(){const e=this.data.players;e[0].info.isChecked||e[1].info.isChecked,this.checkedPlayer()}winner(){this.info.won}checkmate(e){this.info.started=!1,this.info.ended=!0,this.info.won=e,this.winner()}updatePlayers(){this.data.players.forEach((e=>e.update()))}checkedPlayer(){return this.data.players.filter((e=>1==e.info.isChecked))[0]}changeTurn(){const e=this.info.turn,t=this.data.players;this.info.turn=t.filter(((i,s)=>t.indexOf(e)!=s))[0]}switchTurn(e){const t=this.data.players;return t.filter(((i,s)=>t.indexOf(e)!=s))[0]}testMove(e,t){const i=this.data.board;if(e=i.filterPiece(this,e),t=i.filterSquare(t),!e||!t)return!1;const s={square:e.square,piece:t.piece};let n=s.piece?s.piece.player:null,a=s.piece?n.data.pieces:null,o=s.piece?a.indexOf(s.piece):null,r=!1;return o&&a.splice(o,1),e.silentMove(t),r=this.data.board.analyze(),e.silentMove(s.square),t.piece=s.piece,o&&a.splice(o,0,s.piece),r}moved(...e){this.data.board.resetSquares(),this.data.board.setMovedSquare(...e),this.changeTurn(),this.notify(),this.isMate(),this.updatePlayers(),this.insertToMatchHistory(...e)}insertToMatchHistory(e,t){const i={piece:t.piece.getAlias(),from:e.info.position,to:t.info.position};this.data.matchHistory.push(i),t.piece.player.data.movesHistory.push(i)}async loadMatchHistory(e){const t="string"==typeof e;if(!("object"==typeof e)&&!t)throw new Error("Invalid Match History!");if(t)try{e=await fetch(e),e=await e.json()}catch(e){throw new Error("Error, Can't load match history!")}if(0==e.length)throw new Error("Empty Match History!");this.previewMatchHistory(e)}async previewMatchHistory(e,t=0){const i=this.data.board;this.info.preview=!0;const s=async function(e,t,s){return new Promise((n=>{setTimeout((function(){t||n(),i.setSquarePossibilities(t.getPossibleSqOnly()),n(e.move(t,s))}),1e3)}))};for(let n=0;n<e.length;n++){let a=this.data.players[t],o=i.filterPiece(a,e[n].piece),r=i.filterSquare(e[n].to);if(!await s(a,o,r))throw new Error(`Opps Something is wrong, Movement ${e[n].from} to ${e[n].to} is not right`);t=0==t?1:0}this.info.preview=!1}setTime(e,t){return 60*parseInt(e)??0+parseInt(t)??0}parseTime(e){let t=parseInt(e/60,10),i=parseInt(e%60,10);return t=t<10?"0"+t:t,i=i<10?"0"+i:i,{minutes:t,seconds:i,text:t+":"+i}}isReady(){return this.info.started&&!this.info.ended&&!this.info.won}isMate(){const e=this.info.turn,t=e.data.pieces,i=this.data.board.findPiece(t,"King",!0),s=[];if(e.info.isChecked){for(const e of t)for(const t of e.getPossibilities().moves)this.testMove(e,t)&&s.push(e);if(!s.length&&!i.getPossibleSqOnly())return this.checkmate(this.switchTurn(e)),!0}}}class Board{constructor(e){this.default={col_row:8,col:["a","b","c","d","e","f","g","h"],row:[8,7,6,5,4,3,2,1]},this.game=e,this.data=[]}create(){const e=this.default.col_row,t=this.default.col,i=this.default.row;let s="white";const n=()=>s="white"==s?"black":"white";for(let s=0;s<e;s++){const a=[];for(let o=0;o<e;o++){const e=t[o],r=i[s],c=new Square({y:s,x:o},`${e}${r}`,n(),this.game);a.push(c)}this.data.push(a)&&n()}}placePiecesAsDefault(){const e=this,t=this.game.data.players,i=function(t){const i=t.info.position,s=e.filterSquare(i),n=t.info.element,a=s.info.element;t.square=s,s.piece=t,a.appendChild(n)};t.forEach((e=>e.data.pieces.forEach(i)))}getAllPossibilities(){const e=this.game.data.players;return{white:e[0].analyze(),black:e[1].analyze()}}analyze(){let e=!0,t=this.game.info.turn,i=this.getAllPossibilities(),s=Object.entries(i);for(let i of s){const s=this.findPiece(i[1].enemies,"King");if(s){s.player.info.isChecked=!0,t.data.role!=i[0]&&(e=!1,s.player.info.isChecked=!1);break}}return e}setSquarePossibilities(e,t){if(!e)return;let{moves:i,enemies:s,castling:n}=e;this.resetSquares(),i.forEach((e=>e.setAs("move",!0,t))),s.forEach((e=>e.setAs("enemy",!0,t))),n.forEach((e=>e.setAs("castling",!0,t)))}resetSquares(){for(let e of this.data)for(let t of e)t.setAs("move",!1,!0),t.setAs("enemy",!1,!0),t.setAs("castling",!1,!0),t.setAs("from",!1,!0),t.setAs("to",!1,!0)}setMovedSquare(e,t){e.setAs("from",!0,!0),t.setAs("to",!0,!0)}isValidPos(e,t){return!!this.data[e]&&this.data[e][t]}filterSquare(e){if(!e||"object"==typeof e)return e;for(let t of this.data)for(let i of t)if(i.info.position==e)return i}filterPiece(e,t){if(!t||!e||"object"==typeof t)return t;const i=e.data.pieces,s=t.substring(0,2),n=t.charAt(2);for(let e of i)if(e.info.alias==s&&e.info.index==n)return e}findPiece(e,t,i){if(!e||!e.length||!t)return!1;t=this.filterPiece(t)??t;return e.filter((e=>{const s=i?e:"object"==typeof e?e.piece:this.filterSquare(e).piece,n=t.info?t.info.name:t,a=t.info?t.info.alias:t;return s.info.name==n||s.info.alias==a})).map((e=>this.filterSquare(e).piece??e))[0]??!1}}class Piece{constructor(e,t,i){this.info={...e,fastpawn:"Pawn"==e.name,castling:"King"==e.name,element:null},this.data={},this.player=t,this.game=i,this.init()}init(){this.create(),this.listener()}eat(e){if(!e)return;const t=e.player,i=this.player;return e.info.element&&e.info.element.remove(),t.data.dropped.push(e),t.data.pieces.splice(t.data.pieces.indexOf(e),1),i.data.eated.push(e),e}moveElementTo(e){this.info.fastpawn=!1,this.info.castling=!1,e.info.element.appendChild(this.info.element)}move(e,t){let i=this.square;this.eat(e.piece),this.silentMove(e),this.moveElementTo(e),this.game.moved(i,e),t&&this.castling()}silentMove(e){const t=this;(e=this.game.data.board.filterSquare(e)).piece=!1,t.square.piece=!1,e.piece=t,t.square=e,t.info.position=e.info.position,t.square.piece=t}castling(){if("King"!=this.info.name)return!1;const e=this.game.data.board.data,{x:t,y:i}=this.square.info.boardPosition,s=function(e,t,i){i&&(e.silentMove(t),e.moveElementTo(t))},n=e[i][t+1].piece,a=e[i][t-2].piece;s(n,e[i][t-1],n&&"Rook"==n.info.name),s(a,e[i][t+1],a&&"Rook"==a.info.name)}create(){const e=new Image;e.src=`./assets/media/pieces/${this.info.alias}.png`,e.classList.add("chessboard-piece"),this.info.element=e}listener(){const e=this,t=this.game,i=this.info.element,s=t.data.board;i.addEventListener("mousedown",(function(n){let a,o,r=null;if(t.info.preview)return;const c=function(e,t){i.style.cursor="grabbing",i.style.left=e-i.offsetWidth/2+"px",i.style.top=t-i.offsetHeight/2+"px"},l=function(e){c(e.pageX,e.pageY),i.hidden=!0,a=document.elementFromPoint(e.clientX,e.clientY),i.hidden=!1,a&&(o=a.closest(".chessboard-square"),r!=o&&(r=o))},h=function(){return document.removeEventListener("mousemove",l),i.removeAttribute("style"),!!r&&(t.info.turn==e.player&&void e.player.move(e,r.getAttribute("data-position")))};if(i.style.position="absolute",i.style.zIndex=1e3,i.onmouseup=h,i.ondragstart=function(){return!1},document.addEventListener("mousemove",l),c(n.pageX,n.pageY),t.info.turn!=e.player)return!1;s.setSquarePossibilities(e.getPossibleSqOnly(),!0),e.player.data.currentPiece=e}))}getPossibilities(){const e=this,t=this.square,i=this.player.data.role,s=this.game.data.board,n=s.data,a={moves:[],enemies:[],castling:[]};let{x:o,y:r}=t.info.boardPosition;const c=function(e,t){if(!s.isValidPos(e,t))return!1;const o=n[e][t],r=o.piece;return!(!o||!r)&&(r.player.data.role!=i&&void a.enemies.push(o))},l=function(t,i){if(!s.isValidPos(t,i))return!1;const o=n[t][i],r=o.piece;return!!o&&(r?("Pawn"!=e.info.name&&c(t,i),!1):(a.moves.push(o),!0))},h=function(t,i,l,h,f=8,d){for(let u=1;u<f;u++){const f=t?i?r+u:r-u:r,m=l?h?o+u:o-u:o;if(!s.isValidPos(f,m))return!1;const p=n[f][m],y=p.piece;if(p){if(y){"Pawn"!=e.info.name&&c(f,m);break}if(d&&2==u){const e=function(e){e&&a.castling.push(p)},t=n[f][m+1].piece,i=n[f][m-2].piece;e(t&&"Rook"==t.info.name),e(i&&"Rook"==i.info.name)}a.moves.push(p)}}},f={Pawn:function(){let t=e.info.fastpawn?3:2;for(let e=1;e<t;e++)if("white"==i){if(!l(r-e,o))break}else if(!l(r+e,o))break;"white"==i?(c(r-1,o-1),c(r-1,o+1)):(c(r+1,o-1),c(r+1,o+1))},Rook:function(){h(!0,!1,!1,!1),h(!0,!0,!1,!1),h(!1,!1,!0,!1),h(!1,!1,!0,!0)},Bishope:function(){h(!0,!1,!0,!1),h(!0,!0,!0,!1),h(!0,!1,!0,!0),h(!0,!0,!0,!0)},Knight:function(){l(r-2,o-1),l(r-2,o+1),l(r+2,o-1),l(r+2,o+1),l(r-1,o-2),l(r+1,o-2),l(r-1,o+2),l(r+1,o+2)},Queen:function(){f.Rook(),f.Bishope()},King:function(){l(r-1,o),l(r+1,o),l(r-1,o-1),l(r-1,o+1),l(r+1,o-1),l(r+1,o+1),e.info.castling&&(h(!1,!1,!0,!0,3,!0),h(!1,!1,!0,!1,3,!0))}};return f[this.info.name].call(),a}getPossibleSqOnly(){let{moves:e,enemies:t,castling:i}=this.getPossibilities();const s=this.game,n=e=>e.filter((e=>s.testMove(this,e)));return s.data.board.resetSquares(),e=n(e),t=n(t),i=n(i),!!(e.length||t.length||i.length)&&{moves:e,enemies:t,castling:i}}getAlias(){return`${this.info.alias}${this.info.index}`}}class Square{constructor(e,t,i,s){this.info={boardPosition:e,position:t,role:i,element:null,isMove:!1,isEnemy:!1,isCastle:!1},this.piece=null,this.game=s,this.init()}init(){this.create(),this.listener()}create(){const e=document.createElement("DIV");e.classList.add("chessboard-square"),e.setAttribute("role",this.info.role),e.setAttribute("data-position",this.info.position),chessboardParent.appendChild(e),this.info.element=e}listener(){this.info.element.addEventListener("click",function(){const e=this.game.info.turn,t=this.info,i=t.isMove||t.isEnemy||t.isCastle,s=e.data.currentPiece;if(!i||!s)return!1;e.move(s,this)}.bind(this))}setAs(e,t,i){const s=this.info.element;this.info.isEnemy="enemy"==e&&t,this.info.isMove="move"==e&&t,this.info.isCastle="castling"==e&&t,i&&(t?s.classList.add(e):s.classList.remove(e))}}class Player{constructor(e){this.info={isTurn:!1,isWinner:!1,isStarted:!1,isTimeout:!1,isLeave:!1,isChecked:!1,isReady:!1},this.data={...e,total_moves:0,timer:{m:null,s:null},piecesData:{},pieces:[],dropped:[],eated:[],moves:[],enemies:[],movesHistory:[],currentPiece:null,card:null},this.game=null}analyze(){this.data.moves=[],this.data.enemies=[];const e=this.game.info.turn,t=this.data.pieces,i={moves:[],enemies:[],castling:[]};for(const e of t)for(const t of Object.entries(e.getPossibilities()))for(const e of t[1]){if(!e)return;i[t[0]].includes(e.info.position)||i[t[0]].push(e.info.position)}return this.data.moves=i.moves,this.data.enemies=i.enemies,this.info.isTurn=e.data.username==this.data.username,i}update(){const e=this.game,t=e.data.players.indexOf(this)+1,i=document.querySelector(`.player-card.player-${t}`),s=e.info.turn==this;if(!i)return;const n=i.querySelector(".row-1 .text .headline h4"),a=i.querySelector(".row-1 .text .status span"),o=i.querySelector(".row-2 .timer");n.innerText=this.data.username,a.innerText=s?"Player Turn":"",this.data.card={username:n,status:a,timer:o};try{this.analyze()}catch(e){}}move(e,t){if(!e||!t)return!1;const i=this.game.data.board;e=i.filterPiece(this,e),t=i.filterSquare(t);const s=this.game,n=s.testMove(e,t),a=t.info,o=a.isMove||a.isEnemy||a.isCastle;return!!s.isReady()&&(!!this.info.isReady&&(!this.info.isChecked&&(!this.info.isTimeout&&(!!this.info.isTurn&&(!!o&&(n&&e.move(t,a.isCastle),n))))))}startTimer(){const e=this.game,t=this,i=t.data.card.timer,s=i.querySelector("span");let{m:n,s:a}=t.data.timer,o=parseInt(60*n)+parseInt(a)??0,r=n?o:e.setTime(e.info.timer);const c=function(){let{minutes:n,seconds:a,text:o}=e.parseTime(r);s.innerText=o,t.info.isTurn&&(--r<0&&(i.classList.add("timeout"),t.info.isTimeout=!0,e.info.won=e.switchTurn(t),e.winner(),clearInterval(l)),t.data.timer={m:n,s:a})},l=setInterval(c,1e3);c()}async getPieces(){let e=`./assets/javascript/json/${this.data.role}-pieces.json`,t=await fetch(e);this.data.piecesData=await t.json(),this.info.isReady=!0}async setPieces(){const e=this,t=this.game,i=this.data.pieces;this.data.piecesData.forEach((function(s){let{name:n,length:a,alias:o,position:r}=s,{letter:c,number:l}=r;for(let s=0;s<a;s++){const a=`${c[s]}${l}`,r=new Piece({name:n,alias:o,position:a,index:s},e,t);i.push(r)}}))}async init(e){this.game=e,await this.getPieces(),await this.setPieces(),this.update()}}const Game=new Chess;Game.init((function(){this.start()}));